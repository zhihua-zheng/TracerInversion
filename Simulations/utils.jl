using NCDatasets: defVar
using Oceananigans: location
using Oceananigans.Fields: AbstractField
using Oceananigans.Grids: Center, Face
using Oceananigans.OutputWriters: fetch_and_convert_output, drop_output_dims,
                                  netcdf_spatial_dimensions, output_indices
using Oceananigans.Operators
using Oceananigans.AbstractOperations: KernelFunctionOperation, @at, ‚àÇx, ‚àÇy, ‚àÇz
using Oceananigans.Advection: div_ùêØu, div_ùêØv, div_ùêØw#, div_Uc
using Oceananigans.BoundaryConditions: getbc
using Oceananigans.TurbulenceClosures: viscous_flux_ux, viscous_flux_uy, viscous_flux_uz,
                                       viscous_flux_vx, viscous_flux_vy, viscous_flux_vz,
                                       viscous_flux_wx, viscous_flux_wy, viscous_flux_wz,
                                       diffusive_flux_x, diffusive_flux_y, diffusive_flux_z,
                                       ‚àÇ‚±º_œÑ‚ÇÅ‚±º, ‚àÇ‚±º_œÑ‚ÇÇ‚±º, ‚àÇ‚±º_œÑ‚ÇÉ‚±º
using Oceanostics: perturbation_fields
using Oceanostics.TKEBudgetTerms: œàf

using Oceananigans: prognostic_fields, HydrostaticFreeSurfaceModel
using Oceananigans.Biogeochemistry: biogeochemical_auxiliary_fields


@inline uÀ¢_transport(z) = pm.DÀ¢ * pm.UÀ¢ * (1 - exp(z / pm.DÀ¢)) * cosd(pm.Œ∏‚ÇÄ)
@inline vÀ¢_transport(z) = pm.DÀ¢ * pm.UÀ¢ * (1 - exp(z / pm.DÀ¢)) * sind(pm.Œ∏‚ÇÄ)
@inline uÀ¢(z) = pm.UÀ¢ * exp(z / pm.DÀ¢) * cosd(pm.Œ∏‚ÇÄ)
@inline vÀ¢(z) = pm.UÀ¢ * exp(z / pm.DÀ¢) * sind(pm.Œ∏‚ÇÄ)
@inline BÃÖ(x)  = - pm.M¬≤ * x
@inline VÃÖ(z)  = - pm.M¬≤ / pm.f * (z + pm.Lz/2)

@inline function tracer_bkg(x, z, p)
    p = merge(p, (; i=cmod(p.i, p.n_per_set)))
    return isodd(p.i) ? sin((p.i+1)/2 * œÄ * (x+p.Lx/2)/p.Lx) : cos(p.i/2 * œÄ * z/p.Lz)#cos(p.i/2 * œÄ * (x+p.Lx/2)/p.Lx)
end

@inline function tracer_bkg_grad(x, z, p)
    p = merge(p, (; i=cmod(p.i, p.n_per_set)))
    return isodd(p.i) ? (p.i+1)/2*œÄ/p.Lx * cos((p.i+1)/2 * œÄ * (x+p.Lx/2)/p.Lx) : (-p.i/2*œÄ/p.Lz) * sin(p.i/2 * œÄ * z/p.Lz)#(-p.i/2*œÄ/p.Lx) * sin(p.i/2 * œÄ * (x+p.Lx/2)/p.Lx)
end

@inline function get_time_invariant_fields(grid::RectilinearGrid)
    Tus = Field{Nothing, Nothing, Face}(grid)
    Tvs = Field{Nothing, Nothing, Face}(grid)
    set!(Tus, uÀ¢_transport)
    set!(Tvs, vÀ¢_transport)
    usla = Field(-‚àÇz(Tus))
    vsla = Field(-‚àÇz(Tvs))
    compute!(usla)
    compute!(vsla)

    us = Field{Nothing, Nothing, Face}(grid)
    vs = Field{Nothing, Nothing, Face}(grid)
    set!(us, uÀ¢)
    set!(vs, vÀ¢)
    dusdzla = Field(‚àÇz(us))
    dvsdzla = Field(‚àÇz(vs))
    compute!(dusdzla)
    compute!(dvsdzla)

    Bbak = Field{Center, Nothing, Nothing}(grid)
    Vbak = Field{Nothing, Nothing, Center}(grid)
    set!(Bbak, BÃÖ)
    set!(Vbak, VÃÖ)
    compute!(Bbak)
    compute!(Vbak)

    basic_bak = Dict{Symbol, Any}(:us => usla, :vs => vsla, :dusdz => dusdzla, :dvsdz => dvsdzla,
                                  :Bbak => Bbak, :Vbak => Vbak)

    #Cbak  = Dict{Symbol, Any}(Symbol(:Cbak, i) => Field{Center, Nothing, Center}(grid) for i in 1:(pm.n_tracers - 2))
    #CbakG = Dict{Symbol, Any}(Symbol(:CbakG,i) => Field{Center, Nothing, Center}(grid) for i in 1:(pm.n_tracers - 2))
    #for i in 1:(pm.n_tracers - 2)
    #    tracer_params = (; pm.n_per_set, pm.Lx, pm.Lz, i)
    #    set!(Cbak[Symbol(:Cbak, i)], (x, z) -> tracer_bkg(x, z, tracer_params))
    #    compute!(Cbak[Symbol(:Cbak, i)])

    #    set!(CbakG[Symbol(:CbakG, i)], (x, z) -> tracer_bkg_grad(x, z, tracer_params))
    #    compute!(CbakG[Symbol(:CbakG, i)])
    #end
    #return merge(basic_bak, Cbak, CbakG)
    return basic_bak
end


@inline define_time_invariant_variable!(dataset, output::AbstractField, name, array_type, deflatelevel, output_attributes) =
    defVar(dataset, name, eltype(array_type), netcdf_spatial_dimensions(output),
           deflatelevel=deflatelevel, attrib=output_attributes)


@inline function save_output!(ds, output, model, ow, name)
    data = fetch_and_convert_output(output, model, ow)
    data = drop_output_dims(output, data)
    colons = Tuple(Colon() for _ in 1:ndims(data))
    ds[name][colons...] = data
    return nothing
end


@inline function write_time_invariant_fields!(model, ow::NetCDFOutputWriter, ti_fields; user_indices=(:, :, :), with_halos=false)
    ds = open(ow)
    @sync for (ti_field_name, ti_field) in ti_fields 
        indices = output_indices(ti_field, ti_field.grid, user_indices, with_halos)
        sliced_ti_field = Field(ti_field, indices=indices)

        define_time_invariant_variable!(ds, sliced_ti_field, ti_field_name, ow.array_type, 0, Dict())
        @async save_output!(ds, sliced_ti_field, model, ow, ti_field_name)
    end
    close(ds)
end


ccf_scratch = Field{Center, Center,  Face}(grid)
fff_scratch = Field{Face,   Face,    Face}(grid)
ccc_scratch = Field{Center, Center,  Center}(grid)
cnc_scratch = Field{Center, Nothing, Center}(grid)
cnf_scratch = Field{Center, Nothing, Face}(grid)
fnc_scratch = Field{Face,   Nothing, Center}(grid)
fnf_scratch = Field{Face,   Nothing, Face}(grid)
CellCenter  = (Center, Center, Center)

@inline function y_average(F; field=false)
    avg = Average(F, dims=2)
    if field
        LX, LY, LZ = location(F)
        if LX==Center && LZ==Center
            avg = Field(avg, data=cnc_scratch.data)

        elseif LX==Center && LZ==Face
            avg = Field(avg, data=cnf_scratch.data)

        elseif LX==Face && LZ==Center
            avg = Field(avg, data=fnc_scratch.data)

        elseif LX==Face && LZ==Face
            avg = Field(avg, data=fnf_scratch.data)
        end
    end
    return avg
end

@inline Field_ccc(op) = Field((@at CellCenter op), data=ccc_scratch.data)


# ‚àÇ‚±ºu‚ÇÅ ‚ãÖ F‚ÇÅ‚±º
@inline Ax·∂ú·∂ú·∂ú_Œ¥u·∂ú·∂ú·∂ú_F‚ÇÅ‚ÇÅ·∂ú·∂ú·∂ú(i, j, k, grid, closure, K_fields, clo, vels, fields, b) = -Ax·∂ú·∂ú·∂ú(i, j, k, grid) * Œ¥x·∂ú·µÉ·µÉ(i, j, k, grid, vels.u) * viscous_flux_ux(i, j, k, grid, closure, K_fields, clo, fields, b)
@inline Ay·∂†·∂†·∂ú_Œ¥u·∂†·∂†·∂ú_F‚ÇÅ‚ÇÇ·∂†·∂†·∂ú(i, j, k, grid, closure, K_fields, clo, vels, fields, b) = -Ay·∂†·∂†·∂ú(i, j, k, grid) * Œ¥y·µÉ·∂†·µÉ(i, j, k, grid, vels.u) * viscous_flux_uy(i, j, k, grid, closure, K_fields, clo, fields, b)
@inline Az·∂†·∂ú·∂†_Œ¥u·∂†·∂ú·∂†_F‚ÇÅ‚ÇÉ·∂†·∂ú·∂†(i, j, k, grid, closure, K_fields, clo, vels, fields, b) = -Az·∂†·∂ú·∂†(i, j, k, grid) * Œ¥z·µÉ·µÉ·∂†(i, j, k, grid, vels.u) * viscous_flux_uz(i, j, k, grid, closure, K_fields, clo, fields, b)
 
# ‚àÇ‚±ºu‚ÇÇ ‚ãÖ F‚ÇÇ‚±º
@inline Ax·∂†·∂†·∂ú_Œ¥v·∂†·∂†·∂ú_F‚ÇÇ‚ÇÅ·∂†·∂†·∂ú(i, j, k, grid, closure, K_fields, clo, vels, fields, b) = -Ax·∂†·∂†·∂ú(i, j, k, grid) * Œ¥x·∂†·µÉ·µÉ(i, j, k, grid, vels.v) * viscous_flux_vx(i, j, k, grid, closure, K_fields, clo, fields, b)
@inline Ay·∂ú·∂ú·∂ú_Œ¥v·∂ú·∂ú·∂ú_F‚ÇÇ‚ÇÇ·∂ú·∂ú·∂ú(i, j, k, grid, closure, K_fields, clo, vels, fields, b) = -Ay·∂ú·∂ú·∂ú(i, j, k, grid) * Œ¥y·µÉ·∂ú·µÉ(i, j, k, grid, vels.v) * viscous_flux_vy(i, j, k, grid, closure, K_fields, clo, fields, b)
@inline Az·∂ú·∂†·∂†_Œ¥v·∂ú·∂†·∂†_F‚ÇÇ‚ÇÉ·∂ú·∂†·∂†(i, j, k, grid, closure, K_fields, clo, vels, fields, b) = -Az·∂ú·∂†·∂†(i, j, k, grid) * Œ¥z·µÉ·µÉ·∂†(i, j, k, grid, vels.v) * viscous_flux_vz(i, j, k, grid, closure, K_fields, clo, fields, b)
 
# ‚àÇ‚±ºu‚ÇÉ ‚ãÖ F‚ÇÉ‚±º
@inline Ax·∂†·∂ú·∂†_Œ¥w·∂†·∂ú·∂†_F‚ÇÉ‚ÇÅ·∂†·∂ú·∂†(i, j, k, grid, closure, K_fields, clo, vels, fields, b) = -Ax·∂†·∂ú·∂†(i, j, k, grid) * Œ¥x·∂†·µÉ·µÉ(i, j, k, grid, vels.w) * viscous_flux_wx(i, j, k, grid, closure, K_fields, clo, fields, b)
@inline Ay·∂ú·∂†·∂†_Œ¥w·∂ú·∂†·∂†_F‚ÇÉ‚ÇÇ·∂ú·∂†·∂†(i, j, k, grid, closure, K_fields, clo, vels, fields, b) = -Ay·∂ú·∂†·∂†(i, j, k, grid) * Œ¥y·µÉ·∂†·µÉ(i, j, k, grid, vels.w) * viscous_flux_wy(i, j, k, grid, closure, K_fields, clo, fields, b)
@inline Az·∂ú·∂ú·∂ú_Œ¥w·∂ú·∂ú·∂ú_F‚ÇÉ‚ÇÉ·∂ú·∂ú·∂ú(i, j, k, grid, closure, K_fields, clo, vels, fields, b) = -Az·∂ú·∂ú·∂ú(i, j, k, grid) * Œ¥z·µÉ·µÉ·∂ú(i, j, k, grid, vels.w) * viscous_flux_wz(i, j, k, grid, closure, K_fields, clo, fields, b)

@inline viscous_dissipation_ccc(i, j, k, grid, diffusivity_fields, vels, fields, p) =
    (Ax·∂ú·∂ú·∂ú_Œ¥u·∂ú·∂ú·∂ú_F‚ÇÅ‚ÇÅ·∂ú·∂ú·∂ú(i, j, k, grid,         p.closure, diffusivity_fields, p.clock, vels, fields, p.buoyancy) + # C, C, C
     ‚Ñëxy·∂ú·∂ú·µÉ(i, j, k, grid, Ay·∂†·∂†·∂ú_Œ¥u·∂†·∂†·∂ú_F‚ÇÅ‚ÇÇ·∂†·∂†·∂ú, p.closure, diffusivity_fields, p.clock, vels, fields, p.buoyancy) + # F, F, C  ‚Üí C, C, C
     ‚Ñëxz·∂ú·µÉ·∂ú(i, j, k, grid, Az·∂†·∂ú·∂†_Œ¥u·∂†·∂ú·∂†_F‚ÇÅ‚ÇÉ·∂†·∂ú·∂†, p.closure, diffusivity_fields, p.clock, vels, fields, p.buoyancy) + # F, C, F  ‚Üí C, C, C

     ‚Ñëxy·∂ú·∂ú·µÉ(i, j, k, grid, Ax·∂†·∂†·∂ú_Œ¥v·∂†·∂†·∂ú_F‚ÇÇ‚ÇÅ·∂†·∂†·∂ú, p.closure, diffusivity_fields, p.clock, vels, fields, p.buoyancy) + # F, F, C  ‚Üí C, C, C
     Ay·∂ú·∂ú·∂ú_Œ¥v·∂ú·∂ú·∂ú_F‚ÇÇ‚ÇÇ·∂ú·∂ú·∂ú(i, j, k, grid,         p.closure, diffusivity_fields, p.clock, vels, fields, p.buoyancy) + # C, C, C
     ‚Ñëyz·µÉ·∂ú·∂ú(i, j, k, grid, Az·∂ú·∂†·∂†_Œ¥v·∂ú·∂†·∂†_F‚ÇÇ‚ÇÉ·∂ú·∂†·∂†, p.closure, diffusivity_fields, p.clock, vels, fields, p.buoyancy) + # C, F, F  ‚Üí C, C, C

     ‚Ñëxz·∂ú·µÉ·∂ú(i, j, k, grid, Ax·∂†·∂ú·∂†_Œ¥w·∂†·∂ú·∂†_F‚ÇÉ‚ÇÅ·∂†·∂ú·∂†, p.closure, diffusivity_fields, p.clock, vels, fields, p.buoyancy) + # F, C, F  ‚Üí C, C, C
     ‚Ñëyz·µÉ·∂ú·∂ú(i, j, k, grid, Ay·∂ú·∂†·∂†_Œ¥w·∂ú·∂†·∂†_F‚ÇÉ‚ÇÇ·∂ú·∂†·∂†, p.closure, diffusivity_fields, p.clock, vels, fields, p.buoyancy) + # C, F, F  ‚Üí C, C, C
     Az·∂ú·∂ú·∂ú_Œ¥w·∂ú·∂ú·∂ú_F‚ÇÉ‚ÇÉ·∂ú·∂ú·∂ú(i, j, k, grid,         p.closure, diffusivity_fields, p.clock, vels, fields, p.buoyancy)   # C, C, C
     ) / V·∂ú·∂ú·∂ú(i, j, k, grid) # This division by volume, coupled with the call to A*Œ¥u·µ¢ above, ensures a derivative operation

@inline function KineticEnergyDissipation(model::NonhydrostaticModel; energy_vel=model.velocities)
    parameters = (; model.closure, 
                  model.clock,
                  model.buoyancy)
    return KernelFunctionOperation{Center, Center, Center}(viscous_dissipation_ccc, model.grid, model.diffusivity_fields,
                                                           energy_vel, fields(model), parameters)
end


@inline function u·µ¢_advection·∂ú·∂ú·∂ú(i, j, k, grid, energy_vel, velocities, advection)
    u‚àÇ‚±ºu‚±ºu = ‚Ñëx·∂ú·µÉ·µÉ(i, j, k, grid, œàf, energy_vel.u, div_ùêØu, advection, velocities, velocities.u)
    v‚àÇ‚±ºu‚±ºv = ‚Ñëy·µÉ·∂ú·µÉ(i, j, k, grid, œàf, energy_vel.v, div_ùêØv, advection, velocities, velocities.v)
    w‚àÇ‚±ºu‚±ºw = ‚Ñëz·µÉ·µÉ·∂ú(i, j, k, grid, œàf, energy_vel.w, div_ùêØw, advection, velocities, velocities.w)
    return u‚àÇ‚±ºu‚±ºu + v‚àÇ‚±ºu‚±ºv + w‚àÇ‚±ºu‚±ºw
end

@inline function KineticEnergyAdvection(model::NonhydrostaticModel; velocities=model.velocities, energy_vel=model.velocities)
    return KernelFunctionOperation{Center, Center, Center}(u·µ¢_advection·∂ú·∂ú·∂ú, model.grid, energy_vel, velocities, model.advection)
end


@inline function u·µ¢_div_stress·∂ú·∂ú·∂ú(i, j, k, grid, closure, diffusivity_fields,
                                  clock, model_fields, buoyancy, energy_vel)
    u‚àÇ‚±º_œÑ‚ÇÅ‚±º = ‚Ñëx·∂ú·µÉ·µÉ(i, j, k, grid, œàf, energy_vel.u, ‚àÇ‚±º_œÑ‚ÇÅ‚±º, closure, diffusivity_fields, clock, model_fields, buoyancy)
    v‚àÇ‚±º_œÑ‚ÇÇ‚±º = ‚Ñëy·µÉ·∂ú·µÉ(i, j, k, grid, œàf, energy_vel.v, ‚àÇ‚±º_œÑ‚ÇÇ‚±º, closure, diffusivity_fields, clock, model_fields, buoyancy)
    w‚àÇ‚±º_œÑ‚ÇÉ‚±º = ‚Ñëz·µÉ·µÉ·∂ú(i, j, k, grid, œàf, energy_vel.w, ‚àÇ‚±º_œÑ‚ÇÉ‚±º, closure, diffusivity_fields, clock, model_fields, buoyancy)
    return u‚àÇ‚±º_œÑ‚ÇÅ‚±º + v‚àÇ‚±º_œÑ‚ÇÇ‚±º + w‚àÇ‚±º_œÑ‚ÇÉ‚±º
end

@inline function KineticEnergyStress(model::NonhydrostaticModel; energy_vel=model.velocities)
    dependencies = (model.closure,
                    model.diffusivity_fields,
                    model.clock,
                    fields(model),
                    model.buoyancy,
                    energy_vel)
    return KernelFunctionOperation{Center, Center, Center}(u·µ¢_div_stress·∂ú·∂ú·∂ú, model.grid, dependencies...)
end


@inline function u·µ¢_forcing·∂ú·∂ú·∂ú(i, j, k, grid, forcings, clock, model_fields, energy_vel)
    uF·µò = ‚Ñëx·∂ú·µÉ·µÉ(i, j, k, grid, œàf, energy_vel.u, forcings.u, clock, model_fields)
    vF·µõ = ‚Ñëy·µÉ·∂ú·µÉ(i, j, k, grid, œàf, energy_vel.v, forcings.v, clock, model_fields)
    wF ∑ = ‚Ñëz·µÉ·µÉ·∂ú(i, j, k, grid, œàf, energy_vel.w, forcings.w, clock, model_fields)
    return uF·µò + vF·µõ + wF ∑
end

@inline function KineticEnergyForcing(model::NonhydrostaticModel; energy_vel=model.velocities) 
    dependencies = (model.forcing,
                    model.clock,
                    fields(model),
                    energy_vel)
    return KernelFunctionOperation{Center, Center, Center}(u·µ¢_forcing·∂ú·∂ú·∂ú, model.grid, dependencies...)
end


@inline kernel_getbc(i, j, k, grid, boundary_condition, clock, fields) =
    getbc(boundary_condition, i, j, grid, clock, fields)

@inline function SurfaceMomentumFlux(model::NonhydrostaticModel, momentum_name)
    model_fields = fields(model)
    momentum = model.velocities[momentum_name]
    mom_bc = momentum.boundary_conditions.top
    LX = location(momentum, Int32(1))
    LY = location(momentum, Int32(2))
    return KernelFunctionOperation{LX, LY, Nothing}(kernel_getbc, model.grid, mom_bc, model.clock, model_fields)
end

@inline function SurfaceTracerFlux(model::NonhydrostaticModel, tracer_name)
    model_fields = fields(model)
    tracer = model.tracers[tracer_name]
    tra_bc = tracer.boundary_conditions.top
    LX = location(tracer, Int32(1))
    LY = location(tracer, Int32(2))
    return KernelFunctionOperation{LX, LY, Nothing}(kernel_getbc, model.grid, tra_bc, model.clock, model_fields)
end


@inline function XSubgridscaleNormalStress(model::NonhydrostaticModel)
    return KernelFunctionOperation{Center, Center, Center}(viscous_flux_ux, model.grid, model.closure,
                                                           model.diffusivity_fields, model.clock, fields(model), model.buoyancy)
end

@inline function YSubgridscaleNormalStress(model::NonhydrostaticModel)
    return KernelFunctionOperation{Center, Center, Center}(viscous_flux_vy, model.grid, model.closure,
                                                           model.diffusivity_fields, model.clock, fields(model), model.buoyancy)
end

@inline function ZSubgridscaleNormalStress(model::NonhydrostaticModel)
    return KernelFunctionOperation{Center, Center, Center}(viscous_flux_wz, model.grid, model.closure,
                                                           model.diffusivity_fields, model.clock, fields(model), model.buoyancy)
end

@inline function XSubgridscaleVerticalMomentumFlux(model::NonhydrostaticModel)
    return KernelFunctionOperation{Face, Center, Face}(viscous_flux_uz, model.grid, model.closure,
                                                       model.diffusivity_fields, model.clock, fields(model), model.buoyancy)
end

@inline function YSubgridscaleVerticalMomentumFlux(model::NonhydrostaticModel)
    return KernelFunctionOperation{Center, Face, Face}(viscous_flux_vz, model.grid, model.closure,
                                                       model.diffusivity_fields, model.clock, fields(model), model.buoyancy)
end

@inline function SubgridscaleTracerFlux(model::NonhydrostaticModel, tracer_name, direction; tracer=nothing)
    tracer_index = findfirst(n -> n === tracer_name, propertynames(model.tracers))
    tracer = tracer==nothing ? model.tracers[tracer_name] : tracer
    sgs_flux_func = direction==1 ? diffusive_flux_x : (direction==2 ? diffusive_flux_y : diffusive_flux_z)
    LX = direction==1 ? Face : Center
    LY = direction==2 ? Face : Center
    LZ = direction==3 ? Face : Center
    return KernelFunctionOperation{LX, LY, LZ}(sgs_flux_func, model.grid, model.closure,
                                               model.diffusivity_fields, Val(tracer_index), tracer,
                                               model.clock, fields(model), model.buoyancy)
end


@inline function Ertel_potential_vorticity_fff(i, j, k, grid, u, v, w, b, fx, fy, fz, dVgdz, dBdx)
    dWdy =  ‚Ñëx·∂†·µÉ·µÉ(i, j, k, grid, ‚àÇy·∂ú·∂†·∂†, w) # C, C, F  ‚Üí C, F, F  ‚Üí F, F, F
    dVdz =  ‚Ñëx·∂†·µÉ·µÉ(i, j, k, grid, ‚àÇz·∂ú·∂†·∂†, v) # C, F, C  ‚Üí C, F, F  ‚Üí F, F, F
    dbdx = ‚Ñëyz·µÉ·∂†·∂†(i, j, k, grid, ‚àÇx·∂†·∂ú·∂ú, b) # C, C, C  ‚Üí F, C, C  ‚Üí F, F, F
    pv_x = (fx + dWdy - dVdz - dVgdz) * (dbdx + dBdx) # F, F, F

    dUdz =  ‚Ñëy·µÉ·∂†·µÉ(i, j, k, grid, ‚àÇz·∂†·∂ú·∂†, u) # F, C, C  ‚Üí F, C, F ‚Üí F, F, F
    dWdx =  ‚Ñëy·µÉ·∂†·µÉ(i, j, k, grid, ‚àÇx·∂†·∂ú·∂†, w) # C, C, F  ‚Üí F, C, F ‚Üí F, F, F
    dbdy = ‚Ñëxz·∂†·µÉ·∂†(i, j, k, grid, ‚àÇy·∂ú·∂†·∂ú, b) # C, C, C  ‚Üí C, F, C ‚Üí F, F, F
    pv_y = (fy + dUdz - dWdx) * dbdy # F, F, F

    dVdx =  ‚Ñëz·µÉ·µÉ·∂†(i, j, k, grid, ‚àÇx·∂†·∂†·∂ú, v) # C, F, C  ‚Üí F, F, C ‚Üí F, F, F
    dUdy =  ‚Ñëz·µÉ·µÉ·∂†(i, j, k, grid, ‚àÇy·∂†·∂†·∂ú, u) # F, C, C  ‚Üí F, F, C ‚Üí F, F, F
    dbdz = ‚Ñëxy·∂†·∂†·µÉ(i, j, k, grid, ‚àÇz·∂ú·∂ú·∂†, b) # C, C, C  ‚Üí C, C, F ‚Üí F, F, F
    pv_z = (fz + dVdx - dUdy) * dbdz

    return pv_x + pv_y + pv_z
end

@inline function ErtelPotentialVorticityFrontalZone(model::NonhydrostaticModel, u, v, w, b, coriolis; M¬≤=0)
    if coriolis isa FPlane
        fx = fy = 0
        fz = coriolis.f
    elseif coriolis isa ConstantCartesianCoriolis
        fx = coriolis.fx
        fy = coriolis.fy
        fz = coriolis.fz
    elseif coriolis == nothing
        fx = fy = fz = 0
    else
        throw(ArgumentError("ErtelPotentialVorticityFrontalZone is only implemented for FPlane and ConstantCartesianCoriolis"))
    end

    dBdx  = - M¬≤
    dVgdz = dBdx / fz
    return KernelFunctionOperation{Face, Face, Face}(Ertel_potential_vorticity_fff, model.grid,
                                                     u, v, w, b, fx, fy, fz, dVgdz, dBdx)
end
